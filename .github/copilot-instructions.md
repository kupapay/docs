# KutaPay — Copilot Instructions

## What This Project Is
KutaPay is **fiscal compliance infrastructure** for the Democratic Republic of Congo (DRC). It is NOT an invoicing SaaS — it is the trusted layer that turns commercial activity into legally recognized tax events under DRC's "Facture Normalisée" mandate.

The system has two clearly separated halves:
- **Software (untrusted):** POS application (Odoo-inspired), cloud sync, UI, payments, printing/WhatsApp delivery
- **Hardware (trusted):** USB Fiscal Memory device — the sole fiscal authority that signs, numbers, timestamps, and immutably stores invoices

## Architecture — Trust Boundary

```
POS/Phone/Tablet (untrusted)  ──canonical payload──►  USB Fiscal Memory (trusted)
         │                                                    │
         ▼                                                    │
   KutaPay Cloud ──sealed invoice──► DGI (Tax Authority)      │
         ▲                                                    │
         └────────── fiscal response ─────────────────────────┘
```

**Key rule:** The USB device never talks to DGI. Only the POS or KutaPay Cloud uploads sealed invoices. The device is per-outlet, not per-cashier — multiple POS terminals share one fiscal authority via local network.

## Core Design Files
- [kutapay_technical_design.md](../kutapay_technical_design.md) — Architecture, BOM, data structures, API requirements, implementation phases
- [DISCUSSION.md](../DISCUSSION.md) — Full regulatory analysis, design decisions, competitor analysis, and rationale (12K+ lines of context)

## Hardware: USB Fiscal Memory
- USB-C female port, cable-connected (not a dongle)
- Secure MCU + Secure Element (ATECC608/SE050-class) + Flash + RTC
- Target COGS: $10–15
- Inspired by: Italian fiscal memory, African EFDs (Rwanda/Senegal), crypto hardware wallets (Trezor)
- Must enforce: sequential counters, append-only journal, hash chaining, anti-rollback, secure boot, tamper detection
- Protocol: USB CDC (virtual serial), two-phase commit (PREPARE → COMMIT), canonical JSON payloads

## Invoice Lifecycle (non-negotiable)
1. POS prepares invoice with items, VAT, totals
2. POS sends canonical payload to USB device
3. Device validates, increments counter, signs, stores immutably
4. Device returns: fiscal number + auth code + timestamp
5. POS prints/sends receipt with security elements + QR code
6. POS/Cloud uploads sealed invoice to DGI (immediate or deferred)

**Nothing is ever deleted.** Voids and refunds are new fiscal events referencing the original. Draft cancellations (pre-fiscalization) leave no fiscal trace.

## Required Invoice Types
Sale invoice, advance invoice, credit note, export invoice, export credit note

## Required Reports
Z report (daily closure), X report (periodic), A report (article-level), audit export

## Tax Engine
Must support **14 DGI-defined tax groups** including: exempt, standard VAT, special regimes, public financing VAT, customs VAT, specific taxes. Client classification is mandatory (individual, company, commercial individual, professional, embassy).

## Security Elements (mandatory on every invoice)
- Sequential fiscal invoice number (device-controlled)
- Device ID (DEF NID)
- Cryptographic authentication code (signature)
- Trusted timestamp
- QR code encoding verification data

These must be generated by the trusted fiscal layer, never by the POS alone.

## Offline-First Design
Offline issuance is mandatory — internet is never an excuse. The device fiscalizes locally; transmission is deferred. Invoices queued in POS/Cloud sync automatically when connectivity returns. The device uses monotonic counters + time anchoring for ordering integrity.

## Multi-Terminal Scaling
One USB per outlet, not per cashier. For retail (10 lanes) or restaurants (mobile waiters), a local fiscal service mediates between multiple POS clients and one USB device over Wi-Fi/LAN. Each payload includes outlet ID, POS terminal ID, and cashier/waiter ID.

## Current Phase & Strategy
- **Phase 1:** B2B pilot (service companies, wholesalers, schools) — lower volume, easier compliance
- **Phase 2:** Retail/restaurants with multi-terminal support
- **Phase 3:** ERP integrations, large enterprise, national scale

Integration priority: core fiscal API → CSV import/export → accounting export → webhooks → ecommerce plugins → ERP connectors

## Open Unknowns (blocking full implementation)
- MCF/e-MCF API spec (endpoint, auth, schema, offline rules)
- Exact signature algorithm and QR payload format
- Device registration/activation protocol with DGI
- Key provisioning model (device-generated vs DGI-issued)

## Conventions for AI Agents
- Always respect the trust boundary: POS is untrusted, USB device is the authority
- Invoice mutations (void/refund) are always new fiscal events, never deletions
- When designing data models, include: `device_id`, `fiscal_number`, `auth_code`, `timestamp` as mandatory fields
- Canonical payloads must have deterministic field ordering for reproducible signatures
- Tax logic must handle all 14 DGI tax groups — do not hardcode a single VAT rate
- Offline behavior is first-class, not an edge case
- USB protocol uses two-phase commit; partial states must be handled
- The device is per-outlet. Never assume one device per user/cashier
